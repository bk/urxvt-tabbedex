#!/usr/bin/env perl

use warnings;
use strict;

=head1 NAME

command-runner.sample - example script for use with tabbedex tab-arguments

=head1 SYNOPSIS

command-runner.sample B<-n> I<num> [ B<-e> I<command> [ I<args> ]]

=head1 DESCRIPTION

The tabbedex urxvt plugin has a B<tab-arguments> resource.  That resource
defines arguments passed to each tab when it's started.  By taking advantage of
percent-sign-interpolation this feature can be used to customise executed
command based on criteria such as which tab is executed.

This is an example script which can be used for that very purpose.  To make use
of it copy it, make it executable and configure the B<@commands> list near the
beginning of the file.  For example, if urxvt-tabbedex repository is located in
B<~/.urxvt/tabbedex>, the following steps are a good start:

    cd ~/.urxvt/tabbedex
    cp -- command-runner.sample command-runner.pl
    chmod 700 -- command-runner.pl
    ${VISUAL:-${EDITOR:-/bin/vi}} command-runner.pl

Once this is done, the B<tab-arguments> resource must be configured properly,
e.g.:

    URxvt.tabbedex.tab-arguments: \
        -e %~/code/urxvt-tabbedex/command-runner.pl -n %n %e

With this done, each time new tab is started, this script will be run which will
allow what actual command is executed be configured.  See B<@commands> list near
the beginning for some examples.

=head1 CONFIGURATION

The script can be configured via B<@commands> list.  Each entry of the array
determines the command to be run in each subsequent tab.  Once this list runs
out, command given with B<-e> switch (or shell) will be started.

For example, if the first entry is B<['emacs', '-nw']> and the script is run
with B<-n 0> (and without B<-e>) it will execute Emacs.  If B<-e> is given,
application specified by the switch will be run when B<-n 0> was passed and
numbering of B<@commands> entries will be shifted by one.

Entries of the list must be array references.  If you're unfamiliar with Perl,
just surrounded each entry by square brackets and you'll be good. :)

=cut

my @commands = (
	# First tab is shell
	[qw(bash)],
	# Second tab is Emacs
	[qw(emacs -nw)],
	# In third, let’s tail /var/log/syslog
	[qw(tail -f /var/log/syslog)],
);


sub error {
	my $msg = join ': ', @_;
	print STDERR "$0: $msg\n";
}

sub fatal {
	error @_;
	error 'use Ctrl+C to terminate this script';
	sleep;
	exit 1;
}

my ($n, $command);
while (@ARGV) {
	my $arg = shift @ARGV;
	if ($arg !~ /^-[ne]$/) {
		fatal $arg, 'unknown argument';
	} elsif (!@ARGV) {
		fatal $arg, 'requires an argument';
	}
	if ($arg eq '-n') {
		$n = shift @ARGV;
	} elsif ($arg eq '-e') {
		$command = \@ARGV;
		last;
	}
}

if (defined $n) {
	if ($command) {
		# If ‘-e’ was given, the first tab will use it and only second
		# tab will use per-tab configuration.
		--$n;
	}
	if ($n >= 0) {
		$command = $commands[$n] // $command;
	}
} else {
	error '-n switch not present, ignoring per-tab commands';
}

$command = $command // [$ENV{'SHELL'} // '/bin/sh'];
my $prog = $command->[0];
exec $prog @{ $command } or fatal $prog, "$!";
